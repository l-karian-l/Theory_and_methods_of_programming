# Практическая работа №4 - Итератор, посетитель

## План 
1. Реализовать на любом объектно-ориентированном языке программирования

### Итератор

**Итератор** — это поведенческий паттерн проектирования, который даёт возможность
последовательно обходить элементы составных объектов, не раскрывая их внутреннего
представления.

Листинг программы: смотри `Iterator.py`

В этом примере у нас есть класс MyIterator, который реализует итератор, и класс MyCollection, который предоставляет коллекцию для перебора. 
Класс MyIterator имеет методы __iter__() и __next__(), которые позволяют его использовать в цикле for. Класс MyCollection реализует метод __iter__(), который возвращает объект MyIterator для итерации по данным в коллекции.

При запуске кода мы получим вывод, содержащий все элементы в коллекции.

Таким образом, паттерн "Итератор" позволяет нам перебирать элементы 
коллекции без явного раскрытия ее внутренней структуры.

### Посетитель

**Посетитель** — это поведенческий паттерн проектирования, который позволяет добавлять в
программу новые операции, не изменяя классы объектов, над которыми эти операции могут
выполняться.

Листинг программы: смотри `Visitor.py`

В этом примере у нас есть классы Employee, Engineer и Manager, представляющие различных сотрудников. Класс Employee имеет метод accept(), который принимает объект посетителя в качестве аргумента и вызывает его метод visit() для соответствующего элемента.

У нас также есть абстрактный класс Visitor, определяющий метод visit() для посетителей. Мы создаем два конкретных класса посетителей: 
VacationVisitor, который обрабатывает отпуск для каждого сотрудника, и 
PromotionVisitor, который обрабатывает повышение для каждого сотрудника.

В примере мы создаем объекты Engineer и Manager, а затем вызываем 
метод accept() для каждого объекта, передавая соответствующего посетителя. 
Это позволяет посетителям выполнять операции на каждом сотруднике в зависимости от их типа.

Таким образом, паттерн "Посетитель" позволяет добавлять новые операции для набора объектов без изменения самих объектов, разделяя операции в 
отдельных посетителях
