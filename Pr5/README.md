# Практическая работа №5 - Абстрактная фабрика, Строитель, Адаптер, Посредник

## План 
1. Реализовать на любом объектно-ориентированном языке программирования

### Абстрактная фабрика

**Абстрактная фабрика** – это порождающий паттерн проектирования, 
который позволяет создавать семейство связанных объектов, не привязываясь 
к конкретным классам создаваемых объектов.

#### Листинг программы: смотри `Abstract_Factory.py` 

В данном примере у нас есть две конкретные фабрики: 
CarMotorcycleFactory и SUVStreetMotorcycleFactory, которые реализуют 
абстрактную фабрику VehicleFactory. Каждая конкретная фабрика отвечает за 
создание конкретных продуктов, таких как автомобили и мотоциклы. В 
клиентском коде мы используем фабрику CarMotorcycleFactory для создания 
конкретных продуктов (седан и спортивный мотоцикл) и выводим их 
операции.

Таким образом, паттерн "Абстрактная фабрика" позволяет нам создавать 
семейства связанных продуктов, скрывая детали их создания за абстрактными 
классами и фабриками.

### Строитель

**Строитель** – это порождающий паттерн проектирования, который 
позволяет создавать сложные объекты пошагово. Строитель дает возможность 
использовать один и тот же код строительства для получения разных 
представлений объектов. 

#### Листинг программы: смотри `Builder.py`

В данном примере у нас есть продукт Pizza, который мы хотим 
построить с помощью паттерна "Строитель". У нас также есть абстрактный 
класс PizzaBuilder, определяющий интерфейс для построения различных 
типов пицц. Конкретные строители MargheritaPizzaBuilder и 
PepperoniPizzaBuilder реализуют методы для конструирования конкретных 
типов пицц.

Директор PizzaDirector определяет последовательность шагов 
построения пиццы.

В клиентском коде мы создаем экземпляр директора и конкретного 
строителя для пиццы Маргарита. Затем мы передаем строителя директору и 
вызываем метод construct_pizza() для построения пиццы. В результате 
получаем готовую пиццу и выводим ее ингредиенты.

Таким образом, паттерн "Строитель" позволяет нам создавать сложные 
объекты, такие как пиццы, с различными вариантами конфигурации, 
обеспечивая гибкость и избавляя клиентский код от прямого взаимодействия 
с созданием объекта.

### Адаптер

**Адаптер** – структурный паттерн проектирования, который позволяет 
объектам с несовместимыми интерфейсами работать вместе. 

#### Листинг программы: смотри `Adapter.py`

В этом примере у нас есть существующий класс WeatherAPI, который 
предоставляет информацию о погоде, включая температуру и влажность. 
Однако, клиентский код ожидает работу с интерфейсом WeatherProvider, 
который имеет другую спецификацию для получения температуры в градусах 
Цельсия и влажности в процентах.

Чтобы адаптировать WeatherAPI к WeatherProvider, мы создаем класс 
WeatherAdapter, который принимает экземпляр WeatherAPI и реализует 
интерфейс WeatherProvider. Внутри адаптера мы преобразуем значения 
температуры из градусов Фаренгейта в градусы Цельсия и возвращаем 
влажность без изменений.

В клиентском коде мы создаем экземпляр WeatherAPI, затем создаем 
адаптер WeatherAdapter, передавая ему экземпляр WeatherAPI. Затем мы 
можем использовать адаптер для получения значения температуры в градусах 
Цельсия и влажности в процентах.

Таким образом, паттерн "Адаптер" позволяет нам использовать 
существующий класс с несовместимым интерфейсом, преобразуя его в 
интерфейс, ожидаемый клиентским кодом.

### Посредник

**Посредник** — это поведенческий паттерн проектирования, который 
позволяет уменьшить связанность множества классов между собой, благодаря 
перемещению этих связей в один класс-посредник. 

#### Листинг программы: смотри `Broker.py`

В этом примере у нас есть класс TrafficTower, который выступает в роли 
посредника. Он содержит список самолетов и методы для регистрации 
самолетов и отправки сообщений.

Класс Aircraft представляет отдельный самолет, который имеет свой 
уникальный призывной знак (callsign) и ссылку на контрольную башню 
(TrafficTower). У самолета есть методы send_message и receive_message, 
которые позволяют отправлять и принимать сообщения через контрольную 
башню.

Таким образом, паттерн "Посредник" позволяет установить связь между 
объектами через центральный посредник (контрольную башню в данном 
случае), чтобы они могли взаимодействовать друг с другом, минимизируя 
прямые зависимости

