# Практическая работа №3 - Стратегия, Шаблонный метод

## План 
1. Реализовать на любом объектно-ориентированном языке программирования

## Ход работы 

### Стратегия

**Стратегия** — это поведенческий паттерн проектирования, который определяет семейство схожих
алгоритмов и помещает каждый из них в собственный класс, после чего алгоритмы можно
взаимозаменять прямо во время исполнения программы.

Рассмотрим простую игру "Камень, ножницы, бумага": смотри `Strategy.py`

В этом примере паттерн "Стратегия" используется для реализации различных стратегий игры.
GameStrategy - абстрактный класс стратегии, определяющий метод play, который должен быть реализован в каждой конкретной стратегии. 
RockStrategy, ScissorsStrategy и PaperStrategy - конкретные стратегии игры, которые наследуются от GameStrategy и реализуют метод play в соответствии с выбором объекта.

Game - класс игры, который содержит ссылку на текущую стратегию игры. 
Клиент может установить стратегию игры с помощью конструктора и вызвать метод play_game, который выполняет игру с текущей стратегией. В 
данном случае, выбирается случайная стратегия после хода игрока для определения хода компьютера.

### Шаблонный метод

**Шаблонный метод** — это поведенческий паттерн проектирования, который определяет скелет
алгоритма, перекладывая ответственность за некоторые его шаги на подклассы. Паттерн
позволяет подклассам переопределять шаги алгоритма, не меняя его общей структуры.

Рассмотрим процесс приготовления различных типов напитков: смотри `Template_method.py`

В этом примере паттерн "Шаблонный метод" используется для определения общего алгоритма процесса приготовления напитков. 
Абстрактный класс Beverage определяет шаблонный метод prepare(), который вызывает другие методы в определенной последовательности: boil_water(), brew(), pour(), add_condiments(). 
Методы boil_water() и pour() имеют реализацию по умолчанию, которая одинакова для всех наследников, а методы brew() и 
add_condiments() объявлены как абстрактные и должны быть переопределены в конкретных классах.

Конкретные классы Coffee и Tea наследуются от Beverage и реализуют абстрактные методы brew() и add_condiments() в соответствии с конкретным 
типом напитка.

В результате, при создании экземпляров классов Coffee и Tea и вызове 
метода prepare(), будет выполнен общий алгоритм процесса приготовления 
напитков, включая специфические шаги для каждого типа напитка.
